# generated by datamodel-codegen:
#   filename:  schema.deref.yaml
#   timestamp: 2025-08-26T13:26:52+00:00

from __future__ import annotations
from enum import Enum
from typing import Any, Literal, Optional, Union
from pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel, confloat, conint, constr


class Version(Enum):
    v1 = "v1"


class Prompt(BaseModel):
    role: Optional[str] = Field(
        None, description='Prompt role (e.g., "system", "user", "assistant")'
    )
    content: str = Field(..., description='Prompt content (e.g., "You are a helpful assistant.")')


class Tag(RootModel[constr(pattern=r"^[a-z0-9_-]+$")]):
    root: constr(pattern=r"^[a-z0-9_-]+$")


class UseCase(RootModel[constr(min_length=3)]):
    root: constr(min_length=3)


class Type(Enum):
    CSVParser = "CSVParser"
    PDFParser = "PDFParser"
    MarkdownParser = "MarkdownParser"
    HTMLParser = "HTMLParser"
    DocxParser = "DocxParser"
    ExcelParser = "ExcelParser"
    PlainTextParser = "PlainTextParser"


class Config(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    content_fields: Optional[list[str]] = Field(
        ["subject", "body"], description="Fields to use as document content"
    )
    metadata_fields: Optional[list[str]] = Field([], description="Fields to store as metadata")
    id_field: Optional[str] = Field("id", description="Field to use as document ID")
    combine_content: Optional[bool] = Field(
        False, description="Whether to combine multiple content fields"
    )
    content_separator: Optional[str] = Field(" ", description="Separator for combined content")
    encoding: Optional[str] = Field("utf-8", description="CSV file encoding")
    delimiter: Optional[constr(max_length=1)] = Field(",", description="CSV delimiter character")


class Config1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_metadata: Optional[bool] = Field(True, description="Extract PDF metadata")
    extract_page_structure: Optional[bool] = Field(True, description="Extract page-level structure")
    combine_pages: Optional[bool] = Field(
        True, description="Combine all pages into single document"
    )
    page_separator: Optional[str] = Field(
        "\n\n--- Page Break ---\n\n", description="Separator between pages"
    )
    min_text_length: Optional[conint(ge=0)] = Field(
        10, description="Minimum text length to include page"
    )
    include_page_numbers: Optional[bool] = Field(True, description="Include page numbers in text")
    extract_outline: Optional[bool] = Field(True, description="Extract document outline")
    extract_images: Optional[bool] = Field(False, description="Extract embedded images")
    ocr_enabled: Optional[bool] = Field(False, description="Enable OCR for scanned documents")


class Config2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_metadata: Optional[bool] = Field(True, description="Extract YAML frontmatter")
    extract_headings: Optional[bool] = Field(True, description="Extract heading structure")
    extract_links: Optional[bool] = Field(True, description="Extract all links")
    extract_code_blocks: Optional[bool] = Field(True, description="Extract code blocks")
    chunk_by_headings: Optional[bool] = Field(False, description="Split by headings")
    preserve_formatting: Optional[bool] = Field(False, description="Preserve Markdown formatting")
    heading_level_split: Optional[conint(ge=1, le=6)] = Field(
        2, description="Heading level for splitting"
    )


class Config3(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_metadata: Optional[bool] = Field(True, description="Extract meta tags")
    extract_links: Optional[bool] = Field(True, description="Extract hyperlinks")
    extract_images: Optional[bool] = Field(True, description="Extract image sources")
    preserve_structure: Optional[bool] = Field(False, description="Preserve HTML structure")
    remove_scripts: Optional[bool] = Field(True, description="Remove JavaScript")
    remove_styles: Optional[bool] = Field(True, description="Remove CSS")
    text_only: Optional[bool] = Field(False, description="Extract only text")


class Config4(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_metadata: Optional[bool] = Field(True, description="Extract document properties")
    extract_headers_footers: Optional[bool] = Field(True, description="Include headers and footers")
    extract_comments: Optional[bool] = Field(True, description="Extract comments")
    extract_tables: Optional[bool] = Field(True, description="Extract tables")
    extract_images: Optional[bool] = Field(False, description="Extract images")
    preserve_formatting: Optional[bool] = Field(False, description="Preserve text formatting")


class TableFormat(Enum):
    csv = "csv"
    markdown = "markdown"
    json = "json"
    text = "text"


class Config5(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    sheet_names: Optional[list[str]] = Field(None, description="Specific sheets to parse")
    combine_sheets: Optional[bool] = Field(False, description="Combine all sheets")
    extract_formulas: Optional[bool] = Field(False, description="Extract cell formulas")
    extract_charts: Optional[bool] = Field(False, description="Extract chart metadata")
    table_format: Optional[TableFormat] = Field("markdown", description="Table output format")
    header_row: Optional[conint(ge=0)] = Field(0, description="Header row index")


class ChunkStrategy(Enum):
    characters = "characters"
    sentences = "sentences"
    paragraphs = "paragraphs"


class Config6(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    encoding: Optional[str] = Field(
        "auto", description="Text encoding (auto-detect or specify like utf-8, latin1, etc.)"
    )
    chunk_size: Optional[conint(ge=100, le=50000)] = Field(
        None, description="Chunk size in characters (null for no chunking)"
    )
    chunk_overlap: Optional[conint(ge=0, le=5000)] = Field(
        0, description="Overlap between chunks in characters"
    )
    chunk_strategy: Optional[ChunkStrategy] = Field(
        "characters", description="Chunking strategy - how to split the text"
    )
    respect_sentence_boundaries: Optional[bool] = Field(
        True, description="Avoid splitting sentences in the middle when using character chunking"
    )
    respect_paragraph_boundaries: Optional[bool] = Field(
        False,
        description="Avoid splitting paragraphs in the middle (overrides sentence boundaries)",
    )
    min_chunk_size: Optional[conint(ge=10, le=1000)] = Field(
        50, description="Minimum chunk size to avoid creating tiny chunks"
    )
    preserve_line_breaks: Optional[bool] = Field(
        True, description="Preserve line breaks in the text"
    )
    strip_empty_lines: Optional[bool] = Field(
        True, description="Remove empty lines while preserving paragraph structure"
    )
    detect_structure: Optional[bool] = Field(
        True, description="Detect and extract structural elements (headers, lists, code blocks)"
    )


class Parser(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type
    config: Union[Config, Config1, Config2, Config3, Config4, Config5, Config6]


class Type1(Enum):
    KeywordExtractor = "KeywordExtractor"
    EntityExtractor = "EntityExtractor"
    DateTimeExtractor = "DateTimeExtractor"
    HeadingExtractor = "HeadingExtractor"
    LinkExtractor = "LinkExtractor"
    PathExtractor = "PathExtractor"
    PatternExtractor = "PatternExtractor"
    StatisticsExtractor = "StatisticsExtractor"
    SummaryExtractor = "SummaryExtractor"
    TableExtractor = "TableExtractor"


class Algorithm(Enum):
    rake = "rake"
    yake = "yake"
    tfidf = "tfidf"
    textrank = "textrank"


class Config7(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    algorithm: Optional[Algorithm] = Field("rake", description="Extraction algorithm")
    max_keywords: Optional[conint(ge=1, le=100)] = Field(10, description="Maximum keywords")
    min_keyword_length: Optional[conint(ge=1)] = Field(3, description="Minimum keyword length")
    include_scores: Optional[bool] = Field(True, description="Include relevance scores")
    language: Optional[str] = Field("english", description="Language for stop words")


class EntityType(Enum):
    PERSON = "PERSON"
    ORG = "ORG"
    GPE = "GPE"
    DATE = "DATE"
    TIME = "TIME"
    MONEY = "MONEY"
    EMAIL = "EMAIL"
    PHONE = "PHONE"
    URL = "URL"
    LAW = "LAW"


class Config8(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: Optional[str] = Field("en_core_web_sm", description="NER model name")
    entity_types: Optional[list[EntityType]] = Field(
        ["PERSON", "ORG", "GPE", "DATE", "TIME", "MONEY", "EMAIL", "PHONE", "URL"],
        description="Entity types to extract",
    )
    use_fallback: Optional[bool] = Field(True, description="Use regex fallback")
    min_entity_length: Optional[conint(ge=1)] = Field(2, description="Minimum entity length")
    merge_entities: Optional[bool] = Field(True, description="Merge adjacent entities")
    confidence_threshold: Optional[confloat(ge=0.0, le=1.0)] = Field(
        0.7, description="Minimum confidence score"
    )


class PreferDatesFrom(Enum):
    past = "past"
    future = "future"
    current = "current"


class Config9(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fuzzy_parsing: Optional[bool] = Field(True, description="Enable fuzzy parsing")
    extract_relative: Optional[bool] = Field(True, description="Extract relative dates")
    extract_times: Optional[bool] = Field(True, description="Extract time expressions")
    extract_durations: Optional[bool] = Field(True, description="Extract durations")
    default_timezone: Optional[str] = Field("UTC", description="Default timezone")
    date_format: Optional[str] = Field("ISO", description="Output date format")
    prefer_dates_from: Optional[PreferDatesFrom] = Field(
        "current", description="Preference for ambiguous dates"
    )


class Config10(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    max_level: Optional[conint(ge=1, le=6)] = Field(6, description="Maximum heading level")
    include_hierarchy: Optional[bool] = Field(True, description="Include hierarchy structure")
    extract_outline: Optional[bool] = Field(True, description="Generate document outline")
    min_heading_length: Optional[conint(ge=1)] = Field(3, description="Minimum heading length")


class Config11(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_urls: Optional[bool] = Field(True, description="Extract URLs")
    extract_emails: Optional[bool] = Field(True, description="Extract email addresses")
    extract_domains: Optional[bool] = Field(True, description="Extract unique domains")
    validate_urls: Optional[bool] = Field(False, description="Validate URL format")
    resolve_redirects: Optional[bool] = Field(False, description="Resolve URL redirects")


class Config12(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_file_paths: Optional[bool] = Field(True, description="Extract file paths")
    extract_urls: Optional[bool] = Field(True, description="Extract URL paths")
    extract_s3_paths: Optional[bool] = Field(True, description="Extract S3 paths")
    validate_paths: Optional[bool] = Field(False, description="Validate path existence")
    normalize_paths: Optional[bool] = Field(True, description="Normalize path formats")


class PredefinedPattern(Enum):
    email = "email"
    phone = "phone"
    url = "url"
    ip = "ip"
    ssn = "ssn"
    credit_card = "credit_card"
    zip_code = "zip_code"


class CustomPattern(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = Field(..., description="Pattern name")
    pattern: str = Field(..., description="Regex pattern")
    description: Optional[str] = Field(None, description="Pattern description")


class Config13(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    predefined_patterns: Optional[list[PredefinedPattern]] = Field(
        [], description="Predefined patterns"
    )
    custom_patterns: Optional[list[CustomPattern]] = Field([], description="Custom regex patterns")
    case_sensitive: Optional[bool] = Field(False, description="Case-sensitive matching")
    return_positions: Optional[bool] = Field(False, description="Return match positions")


class Config14(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    include_readability: Optional[bool] = Field(True, description="Calculate readability scores")
    include_vocabulary: Optional[bool] = Field(True, description="Analyze vocabulary")
    include_structure: Optional[bool] = Field(True, description="Analyze text structure")
    include_sentiment: Optional[bool] = Field(False, description="Basic sentiment analysis")
    include_language: Optional[bool] = Field(True, description="Detect language")


class Algorithm1(Enum):
    textrank = "textrank"
    lsa = "lsa"
    luhn = "luhn"
    lexrank = "lexrank"


class Config15(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    summary_sentences: Optional[conint(ge=1, le=10)] = Field(
        3, description="Number of summary sentences"
    )
    algorithm: Optional[Algorithm1] = Field("textrank", description="Summarization algorithm")
    include_key_phrases: Optional[bool] = Field(True, description="Extract key phrases")
    include_statistics: Optional[bool] = Field(True, description="Include text statistics")


class OutputFormat(Enum):
    dict = "dict"
    list = "list"
    csv = "csv"
    markdown = "markdown"


class Config16(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    output_format: Optional[OutputFormat] = Field("dict", description="Output format")
    extract_headers: Optional[bool] = Field(True, description="Extract table headers")
    merge_cells: Optional[bool] = Field(True, description="Handle merged cells")
    min_rows: Optional[conint(ge=1)] = Field(2, description="Minimum rows for table")


class Extractor(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type1 = Field(..., description="Extractor type identifier")
    config: Union[
        Config7,
        Config8,
        Config9,
        Config10,
        Config11,
        Config12,
        Config13,
        Config14,
        Config15,
        Config16,
    ]


class Type2(Enum):
    OllamaEmbedder = "OllamaEmbedder"
    OpenAIEmbedder = "OpenAIEmbedder"
    HuggingFaceEmbedder = "HuggingFaceEmbedder"
    SentenceTransformerEmbedder = "SentenceTransformerEmbedder"


class Model(Enum):
    nomic_embed_text = "nomic-embed-text"
    mxbai_embed_large = "mxbai-embed-large"


class Config17(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: Optional[Model] = Field("nomic-embed-text", description="Ollama model name")
    base_url: Optional[AnyUrl] = Field("http://localhost:11434", description="Ollama API endpoint")
    dimension: Optional[conint(ge=128, le=4096)] = Field(768, description="Embedding dimension")
    batch_size: Optional[conint(ge=1, le=128)] = Field(16, description="Batch processing size")
    timeout: Optional[conint(ge=10)] = Field(60, description="Request timeout (seconds)")
    auto_pull: Optional[bool] = Field(True, description="Auto-pull missing models")


class Model1(Enum):
    text_embedding_3_small = "text-embedding-3-small"
    text_embedding_3_large = "text-embedding-3-large"
    text_embedding_ada_002 = "text-embedding-ada-002"


class Config18(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    api_key: str = Field(..., description="OpenAI API key")
    model: Optional[Model1] = Field("text-embedding-3-small", description="OpenAI model")
    dimension: Optional[conint(ge=256, le=3072)] = Field(None, description="Override dimension")
    batch_size: Optional[conint(ge=1, le=2048)] = Field(100, description="Batch size")
    max_retries: Optional[conint(ge=0, le=10)] = Field(3, description="Max retry attempts")


class Device(Enum):
    cpu = "cpu"
    cuda = "cuda"
    mps = "mps"
    auto = "auto"


class Config19(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model_name: Optional[str] = Field(
        "sentence-transformers/all-MiniLM-L6-v2", description="HuggingFace model ID"
    )
    device: Optional[Device] = Field("auto", description="Computation device")
    batch_size: Optional[conint(ge=1, le=256)] = Field(32, description="Batch size")
    normalize_embeddings: Optional[bool] = Field(True, description="L2 normalize embeddings")
    show_progress_bar: Optional[bool] = Field(False, description="Show progress bar")
    cache_folder: Optional[str] = Field(None, description="Model cache directory")


class Device1(Enum):
    cpu = "cpu"
    cuda = "cuda"
    mps = "mps"


class PoolingStrategy(Enum):
    mean = "mean"
    max = "max"
    cls = "cls"


class Config20(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model_name: Optional[str] = Field("all-MiniLM-L6-v2", description="Model name")
    device: Optional[Device1] = Field("cpu", description="Computation device")
    batch_size: Optional[conint(ge=1, le=256)] = Field(32, description="Batch size")
    normalize_embeddings: Optional[bool] = Field(True, description="Normalize embeddings")
    pooling_strategy: Optional[PoolingStrategy] = Field(
        "mean", description="Token pooling strategy"
    )


class Embedder(BaseModel):
    type: Type2
    config: Union[Config17, Config18, Config19, Config20]


class Type3(Enum):
    ChromaStore = "ChromaStore"
    FAISSStore = "FAISSStore"
    PineconeStore = "PineconeStore"
    QdrantStore = "QdrantStore"


class DistanceFunction(Enum):
    cosine = "cosine"
    l2 = "l2"
    ip = "ip"


class Config21(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    collection_name: Optional[constr(pattern=r"^[a-zA-Z0-9_-]+$")] = Field(
        "documents", description="Collection name"
    )
    persist_directory: Optional[str] = Field(
        "./data/chroma_db", description="Persistence directory"
    )
    host: Optional[str] = Field(None, description="Server host")
    port: Optional[conint(ge=1, le=65535)] = Field(8000, description="Server port")
    distance_function: Optional[DistanceFunction] = Field("cosine", description="Distance metric")
    embedding_function: Optional[str] = Field(None, description="Built-in embedding function")


class IndexType(Enum):
    Flat = "Flat"
    IVF = "IVF"
    HNSW = "HNSW"
    LSH = "LSH"


class Metric(Enum):
    L2 = "L2"
    IP = "IP"
    Cosine = "Cosine"


class Config22(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dimension: conint(ge=1, le=4096) = Field(..., description="Vector dimension")
    index_type: Optional[IndexType] = Field("Flat", description="Index type")
    metric: Optional[Metric] = Field("L2", description="Distance metric")
    nlist: Optional[conint(ge=1)] = Field(100, description="Number of clusters (IVF)")
    nprobe: Optional[conint(ge=1)] = Field(10, description="Clusters to search (IVF)")
    use_gpu: Optional[bool] = Field(False, description="Enable GPU acceleration")


class Metric1(Enum):
    euclidean = "euclidean"
    cosine = "cosine"
    dotproduct = "dotproduct"


class Config23(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    api_key: str = Field(..., description="Pinecone API key")
    environment: Optional[str] = Field("us-east-1-aws", description="Pinecone environment")
    index_name: constr(pattern=r"^[a-z0-9-]+$") = Field(..., description="Index name")
    dimension: conint(ge=1, le=20000) = Field(..., description="Vector dimension")
    metric: Optional[Metric1] = Field("cosine", description="Distance metric")
    namespace: Optional[str] = Field("", description="Namespace for isolation")
    replicas: Optional[conint(ge=1, le=20)] = Field(1, description="Number of replicas")


class Distance(Enum):
    Cosine = "Cosine"
    Euclid = "Euclid"
    Dot = "Dot"


class Config24(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    host: Optional[str] = Field("localhost", description="Server host")
    port: Optional[conint(ge=1, le=65535)] = Field(6333, description="Server port")
    grpc_port: Optional[conint(ge=1, le=65535)] = Field(6334, description="gRPC port")
    api_key: Optional[str] = Field(None, description="API key")
    collection_name: Optional[constr(pattern=r"^[a-zA-Z0-9_-]+$")] = Field(
        "documents", description="Collection name"
    )
    vector_size: conint(ge=1, le=65536) = Field(..., description="Vector dimension")
    distance: Optional[Distance] = Field("Cosine", description="Distance metric")
    on_disk: Optional[bool] = Field(False, description="Store vectors on disk")


class VectorStore(BaseModel):
    type: Type3
    config: Union[Config21, Config22, Config23, Config24]


class DistanceMetric(Enum):
    cosine = "cosine"
    euclidean = "euclidean"
    manhattan = "manhattan"
    dot = "dot"


class Config25(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    top_k: Optional[conint(ge=1, le=1000)] = Field(10, description="Number of results")
    distance_metric: Optional[DistanceMetric] = Field("cosine", description="Distance metric")
    score_threshold: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None, description="Minimum similarity score"
    )


class RetrievalStrategy(BaseModel):
    type: Literal["BasicSimilarityStrategy"] = Field(
        ..., description="Retrieval strategy type identifier"
    )
    config: Config25 = Field(..., title="Basic Similarity Configuration")


class FilterMode(Enum):
    pre = "pre"
    post = "post"


class Config26(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    top_k: Optional[conint(ge=1, le=1000)] = Field(10, description="Number of results")
    filters: Optional[dict[str, Union[str, float, bool, list[Union[str, float, bool]]]]] = Field(
        {}, description="Metadata filters"
    )
    filter_mode: Optional[FilterMode] = Field("pre", description="When to apply filters")
    fallback_multiplier: Optional[conint(ge=1, le=10)] = Field(
        3, description="Multiplier for post-filtering"
    )


class RetrievalStrategy1(BaseModel):
    type: Literal["MetadataFilteredStrategy"] = Field(
        ..., description="Retrieval strategy type identifier"
    )
    config: Config26 = Field(..., title="Metadata Filtered Configuration")


class AggregationMethod(Enum):
    max = "max"
    mean = "mean"
    weighted = "weighted"
    reciprocal_rank = "reciprocal_rank"


class Config27(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    num_queries: Optional[conint(ge=1, le=10)] = Field(3, description="Number of query variations")
    top_k: Optional[conint(ge=1, le=1000)] = Field(10, description="Results per query")
    aggregation_method: Optional[AggregationMethod] = Field(
        "weighted", description="Result aggregation method"
    )
    query_weights: Optional[list[confloat(ge=0.0, le=1.0)]] = Field(
        None, description="Weights for each query"
    )


class RetrievalStrategy2(BaseModel):
    type: Literal["MultiQueryStrategy"] = Field(
        ..., description="Retrieval strategy type identifier"
    )
    config: Config27 = Field(..., title="Multi Query Configuration")


class RerankFactors(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    similarity_weight: Optional[confloat(ge=0.0, le=1.0)] = 0.7
    recency_weight: Optional[confloat(ge=0.0, le=1.0)] = 0.1
    length_weight: Optional[confloat(ge=0.0, le=1.0)] = 0.1
    metadata_weight: Optional[confloat(ge=0.0, le=1.0)] = 0.1


class Config28(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    initial_k: Optional[conint(ge=10, le=1000)] = Field(30, description="Initial candidates")
    final_k: Optional[conint(ge=1, le=100)] = Field(10, description="Final results")
    rerank_factors: Optional[RerankFactors] = Field(None, description="Reranking factor weights")
    normalize_scores: Optional[bool] = Field(True, description="Normalize scores before combining")


class RetrievalStrategy3(BaseModel):
    type: Literal["RerankedStrategy"] = Field(..., description="Retrieval strategy type identifier")
    config: Config28 = Field(..., title="Reranked Configuration")


class Type4(Enum):
    BasicSimilarityStrategy = "BasicSimilarityStrategy"
    MetadataFilteredStrategy = "MetadataFilteredStrategy"
    MultiQueryStrategy = "MultiQueryStrategy"
    RerankedStrategy = "RerankedStrategy"


class Strategy1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type4
    weight: Optional[confloat(ge=0.0, le=1.0)] = 1.0
    config: Optional[dict[str, Any]] = None


class CombinationMethod(Enum):
    weighted_average = "weighted_average"
    rank_fusion = "rank_fusion"
    score_fusion = "score_fusion"


class Config29(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategies: Optional[list[Strategy1]] = Field(
        None, description="Sub-strategies to combine", max_length=5, min_length=2
    )
    combination_method: Optional[CombinationMethod] = Field(
        "weighted_average", description="Combination method"
    )
    final_k: Optional[conint(ge=1, le=1000)] = Field(10, description="Final number of results")


class RetrievalStrategy4(BaseModel):
    type: Literal["HybridUniversalStrategy"] = Field(
        ..., description="Retrieval strategy type identifier"
    )
    config: Config29 = Field(..., title="Hybrid Universal Configuration")


class Components(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    parser: Parser = Field(..., description="Parser configuration", title="Parser Configuration")
    extractors: Optional[list[Extractor]] = Field(None, max_length=10)
    embedder: Embedder = Field(..., title="Embedder Configuration")
    vector_store: VectorStore = Field(..., title="Vector Store Configuration")
    retrieval_strategy: Union[
        RetrievalStrategy,
        RetrievalStrategy1,
        RetrievalStrategy2,
        RetrievalStrategy3,
        RetrievalStrategy4,
    ] = Field(..., title="Retrieval Strategy Configuration")


class Strategy(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(pattern=r"^[a-z][a-z0-9_]*$", min_length=1, max_length=50) = Field(
        ...,
        description="Unique strategy identifier",
        examples=["simple", "customer_support", "legal_documents"],
    )
    description: constr(min_length=10, max_length=500) = Field(
        ..., description="Clear description of strategy purpose"
    )
    tags: Optional[list[Tag]] = Field(
        None,
        description="Tags for categorization",
        examples=[["production", "optimized"], ["development", "testing"]],
    )
    use_cases: Optional[list[UseCase]] = Field(None, description="Specific use cases", min_length=1)
    components: Components = Field(..., title="Strategy Components")


class Type5(Enum):
    CSVParser = "CSVParser"
    PDFParser = "PDFParser"
    MarkdownParser = "MarkdownParser"
    HTMLParser = "HTMLParser"
    DocxParser = "DocxParser"
    ExcelParser = "ExcelParser"
    PlainTextParser = "PlainTextParser"


class Config30(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    content_fields: Optional[list[str]] = Field(
        ["subject", "body"], description="Fields to use as document content"
    )
    metadata_fields: Optional[list[str]] = Field([], description="Fields to store as metadata")
    id_field: Optional[str] = Field("id", description="Field to use as document ID")
    combine_content: Optional[bool] = Field(
        False, description="Whether to combine multiple content fields"
    )
    content_separator: Optional[str] = Field(" ", description="Separator for combined content")
    encoding: Optional[str] = Field("utf-8", description="CSV file encoding")
    delimiter: Optional[constr(max_length=1)] = Field(",", description="CSV delimiter character")


class Config31(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_metadata: Optional[bool] = Field(True, description="Extract PDF metadata")
    extract_page_structure: Optional[bool] = Field(True, description="Extract page-level structure")
    combine_pages: Optional[bool] = Field(
        True, description="Combine all pages into single document"
    )
    page_separator: Optional[str] = Field(
        "\n\n--- Page Break ---\n\n", description="Separator between pages"
    )
    min_text_length: Optional[conint(ge=0)] = Field(
        10, description="Minimum text length to include page"
    )
    include_page_numbers: Optional[bool] = Field(True, description="Include page numbers in text")
    extract_outline: Optional[bool] = Field(True, description="Extract document outline")
    extract_images: Optional[bool] = Field(False, description="Extract embedded images")
    ocr_enabled: Optional[bool] = Field(False, description="Enable OCR for scanned documents")


class Config32(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_metadata: Optional[bool] = Field(True, description="Extract YAML frontmatter")
    extract_headings: Optional[bool] = Field(True, description="Extract heading structure")
    extract_links: Optional[bool] = Field(True, description="Extract all links")
    extract_code_blocks: Optional[bool] = Field(True, description="Extract code blocks")
    chunk_by_headings: Optional[bool] = Field(False, description="Split by headings")
    preserve_formatting: Optional[bool] = Field(False, description="Preserve Markdown formatting")
    heading_level_split: Optional[conint(ge=1, le=6)] = Field(
        2, description="Heading level for splitting"
    )


class Config33(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_metadata: Optional[bool] = Field(True, description="Extract meta tags")
    extract_links: Optional[bool] = Field(True, description="Extract hyperlinks")
    extract_images: Optional[bool] = Field(True, description="Extract image sources")
    preserve_structure: Optional[bool] = Field(False, description="Preserve HTML structure")
    remove_scripts: Optional[bool] = Field(True, description="Remove JavaScript")
    remove_styles: Optional[bool] = Field(True, description="Remove CSS")
    text_only: Optional[bool] = Field(False, description="Extract only text")


class Config34(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_metadata: Optional[bool] = Field(True, description="Extract document properties")
    extract_headers_footers: Optional[bool] = Field(True, description="Include headers and footers")
    extract_comments: Optional[bool] = Field(True, description="Extract comments")
    extract_tables: Optional[bool] = Field(True, description="Extract tables")
    extract_images: Optional[bool] = Field(False, description="Extract images")
    preserve_formatting: Optional[bool] = Field(False, description="Preserve text formatting")


class Config35(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    sheet_names: Optional[list[str]] = Field(None, description="Specific sheets to parse")
    combine_sheets: Optional[bool] = Field(False, description="Combine all sheets")
    extract_formulas: Optional[bool] = Field(False, description="Extract cell formulas")
    extract_charts: Optional[bool] = Field(False, description="Extract chart metadata")
    table_format: Optional[TableFormat] = Field("markdown", description="Table output format")
    header_row: Optional[conint(ge=0)] = Field(0, description="Header row index")


class Config36(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    encoding: Optional[str] = Field(
        "auto", description="Text encoding (auto-detect or specify like utf-8, latin1, etc.)"
    )
    chunk_size: Optional[conint(ge=100, le=50000)] = Field(
        None, description="Chunk size in characters (null for no chunking)"
    )
    chunk_overlap: Optional[conint(ge=0, le=5000)] = Field(
        0, description="Overlap between chunks in characters"
    )
    chunk_strategy: Optional[ChunkStrategy] = Field(
        "characters", description="Chunking strategy - how to split the text"
    )
    respect_sentence_boundaries: Optional[bool] = Field(
        True, description="Avoid splitting sentences in the middle when using character chunking"
    )
    respect_paragraph_boundaries: Optional[bool] = Field(
        False,
        description="Avoid splitting paragraphs in the middle (overrides sentence boundaries)",
    )
    min_chunk_size: Optional[conint(ge=10, le=1000)] = Field(
        50, description="Minimum chunk size to avoid creating tiny chunks"
    )
    preserve_line_breaks: Optional[bool] = Field(
        True, description="Preserve line breaks in the text"
    )
    strip_empty_lines: Optional[bool] = Field(
        True, description="Remove empty lines while preserving paragraph structure"
    )
    detect_structure: Optional[bool] = Field(
        True, description="Detect and extract structural elements (headers, lists, code blocks)"
    )


class Parser1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type5
    config: Union[Config30, Config31, Config32, Config33, Config34, Config35, Config36]


class Type6(Enum):
    KeywordExtractor = "KeywordExtractor"
    EntityExtractor = "EntityExtractor"
    DateTimeExtractor = "DateTimeExtractor"
    HeadingExtractor = "HeadingExtractor"
    LinkExtractor = "LinkExtractor"
    PathExtractor = "PathExtractor"
    PatternExtractor = "PatternExtractor"
    StatisticsExtractor = "StatisticsExtractor"
    SummaryExtractor = "SummaryExtractor"
    TableExtractor = "TableExtractor"


class Algorithm2(Enum):
    rake = "rake"
    yake = "yake"
    tfidf = "tfidf"
    textrank = "textrank"


class Config37(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    algorithm: Optional[Algorithm2] = Field("rake", description="Extraction algorithm")
    max_keywords: Optional[conint(ge=1, le=100)] = Field(10, description="Maximum keywords")
    min_keyword_length: Optional[conint(ge=1)] = Field(3, description="Minimum keyword length")
    include_scores: Optional[bool] = Field(True, description="Include relevance scores")
    language: Optional[str] = Field("english", description="Language for stop words")


class Config38(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: Optional[str] = Field("en_core_web_sm", description="NER model name")
    entity_types: Optional[list[EntityType]] = Field(
        ["PERSON", "ORG", "GPE", "DATE", "TIME", "MONEY", "EMAIL", "PHONE", "URL"],
        description="Entity types to extract",
    )
    use_fallback: Optional[bool] = Field(True, description="Use regex fallback")
    min_entity_length: Optional[conint(ge=1)] = Field(2, description="Minimum entity length")
    merge_entities: Optional[bool] = Field(True, description="Merge adjacent entities")
    confidence_threshold: Optional[confloat(ge=0.0, le=1.0)] = Field(
        0.7, description="Minimum confidence score"
    )


class Config39(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    fuzzy_parsing: Optional[bool] = Field(True, description="Enable fuzzy parsing")
    extract_relative: Optional[bool] = Field(True, description="Extract relative dates")
    extract_times: Optional[bool] = Field(True, description="Extract time expressions")
    extract_durations: Optional[bool] = Field(True, description="Extract durations")
    default_timezone: Optional[str] = Field("UTC", description="Default timezone")
    date_format: Optional[str] = Field("ISO", description="Output date format")
    prefer_dates_from: Optional[PreferDatesFrom] = Field(
        "current", description="Preference for ambiguous dates"
    )


class Config40(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    max_level: Optional[conint(ge=1, le=6)] = Field(6, description="Maximum heading level")
    include_hierarchy: Optional[bool] = Field(True, description="Include hierarchy structure")
    extract_outline: Optional[bool] = Field(True, description="Generate document outline")
    min_heading_length: Optional[conint(ge=1)] = Field(3, description="Minimum heading length")


class Config41(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_urls: Optional[bool] = Field(True, description="Extract URLs")
    extract_emails: Optional[bool] = Field(True, description="Extract email addresses")
    extract_domains: Optional[bool] = Field(True, description="Extract unique domains")
    validate_urls: Optional[bool] = Field(False, description="Validate URL format")
    resolve_redirects: Optional[bool] = Field(False, description="Resolve URL redirects")


class Config42(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    extract_file_paths: Optional[bool] = Field(True, description="Extract file paths")
    extract_urls: Optional[bool] = Field(True, description="Extract URL paths")
    extract_s3_paths: Optional[bool] = Field(True, description="Extract S3 paths")
    validate_paths: Optional[bool] = Field(False, description="Validate path existence")
    normalize_paths: Optional[bool] = Field(True, description="Normalize path formats")


class Config43(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    predefined_patterns: Optional[list[PredefinedPattern]] = Field(
        [], description="Predefined patterns"
    )
    custom_patterns: Optional[list[CustomPattern]] = Field([], description="Custom regex patterns")
    case_sensitive: Optional[bool] = Field(False, description="Case-sensitive matching")
    return_positions: Optional[bool] = Field(False, description="Return match positions")


class Config44(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    include_readability: Optional[bool] = Field(True, description="Calculate readability scores")
    include_vocabulary: Optional[bool] = Field(True, description="Analyze vocabulary")
    include_structure: Optional[bool] = Field(True, description="Analyze text structure")
    include_sentiment: Optional[bool] = Field(False, description="Basic sentiment analysis")
    include_language: Optional[bool] = Field(True, description="Detect language")


class Algorithm3(Enum):
    textrank = "textrank"
    lsa = "lsa"
    luhn = "luhn"
    lexrank = "lexrank"


class Config45(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    summary_sentences: Optional[conint(ge=1, le=10)] = Field(
        3, description="Number of summary sentences"
    )
    algorithm: Optional[Algorithm3] = Field("textrank", description="Summarization algorithm")
    include_key_phrases: Optional[bool] = Field(True, description="Extract key phrases")
    include_statistics: Optional[bool] = Field(True, description="Include text statistics")


class Config46(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    output_format: Optional[OutputFormat] = Field("dict", description="Output format")
    extract_headers: Optional[bool] = Field(True, description="Extract table headers")
    merge_cells: Optional[bool] = Field(True, description="Handle merged cells")
    min_rows: Optional[conint(ge=1)] = Field(2, description="Minimum rows for table")


class Extractor1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type6 = Field(..., description="Extractor type identifier")
    config: Union[
        Config37,
        Config38,
        Config39,
        Config40,
        Config41,
        Config42,
        Config43,
        Config44,
        Config45,
        Config46,
    ]


class Type7(Enum):
    OllamaEmbedder = "OllamaEmbedder"
    OpenAIEmbedder = "OpenAIEmbedder"
    HuggingFaceEmbedder = "HuggingFaceEmbedder"
    SentenceTransformerEmbedder = "SentenceTransformerEmbedder"


class Model2(Enum):
    nomic_embed_text = "nomic-embed-text"
    mxbai_embed_large = "mxbai-embed-large"


class Config47(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model: Optional[Model2] = Field("nomic-embed-text", description="Ollama model name")
    base_url: Optional[AnyUrl] = Field("http://localhost:11434", description="Ollama API endpoint")
    dimension: Optional[conint(ge=128, le=4096)] = Field(768, description="Embedding dimension")
    batch_size: Optional[conint(ge=1, le=128)] = Field(16, description="Batch processing size")
    timeout: Optional[conint(ge=10)] = Field(60, description="Request timeout (seconds)")
    auto_pull: Optional[bool] = Field(True, description="Auto-pull missing models")


class Model3(Enum):
    text_embedding_3_small = "text-embedding-3-small"
    text_embedding_3_large = "text-embedding-3-large"
    text_embedding_ada_002 = "text-embedding-ada-002"


class Config48(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    api_key: str = Field(..., description="OpenAI API key")
    model: Optional[Model3] = Field("text-embedding-3-small", description="OpenAI model")
    dimension: Optional[conint(ge=256, le=3072)] = Field(None, description="Override dimension")
    batch_size: Optional[conint(ge=1, le=2048)] = Field(100, description="Batch size")
    max_retries: Optional[conint(ge=0, le=10)] = Field(3, description="Max retry attempts")


class Device2(Enum):
    cpu = "cpu"
    cuda = "cuda"
    mps = "mps"
    auto = "auto"


class Config49(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model_name: Optional[str] = Field(
        "sentence-transformers/all-MiniLM-L6-v2", description="HuggingFace model ID"
    )
    device: Optional[Device2] = Field("auto", description="Computation device")
    batch_size: Optional[conint(ge=1, le=256)] = Field(32, description="Batch size")
    normalize_embeddings: Optional[bool] = Field(True, description="L2 normalize embeddings")
    show_progress_bar: Optional[bool] = Field(False, description="Show progress bar")
    cache_folder: Optional[str] = Field(None, description="Model cache directory")


class Device3(Enum):
    cpu = "cpu"
    cuda = "cuda"
    mps = "mps"


class Config50(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    model_name: Optional[str] = Field("all-MiniLM-L6-v2", description="Model name")
    device: Optional[Device3] = Field("cpu", description="Computation device")
    batch_size: Optional[conint(ge=1, le=256)] = Field(32, description="Batch size")
    normalize_embeddings: Optional[bool] = Field(True, description="Normalize embeddings")
    pooling_strategy: Optional[PoolingStrategy] = Field(
        "mean", description="Token pooling strategy"
    )


class Embedder1(BaseModel):
    type: Type7
    config: Union[Config47, Config48, Config49, Config50]


class Type8(Enum):
    ChromaStore = "ChromaStore"
    FAISSStore = "FAISSStore"
    PineconeStore = "PineconeStore"
    QdrantStore = "QdrantStore"


class Config51(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    collection_name: Optional[constr(pattern=r"^[a-zA-Z0-9_-]+$")] = Field(
        "documents", description="Collection name"
    )
    persist_directory: Optional[str] = Field(
        "./data/chroma_db", description="Persistence directory"
    )
    host: Optional[str] = Field(None, description="Server host")
    port: Optional[conint(ge=1, le=65535)] = Field(8000, description="Server port")
    distance_function: Optional[DistanceFunction] = Field("cosine", description="Distance metric")
    embedding_function: Optional[str] = Field(None, description="Built-in embedding function")


class Metric2(Enum):
    L2 = "L2"
    IP = "IP"
    Cosine = "Cosine"


class Config52(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    dimension: conint(ge=1, le=4096) = Field(..., description="Vector dimension")
    index_type: Optional[IndexType] = Field("Flat", description="Index type")
    metric: Optional[Metric2] = Field("L2", description="Distance metric")
    nlist: Optional[conint(ge=1)] = Field(100, description="Number of clusters (IVF)")
    nprobe: Optional[conint(ge=1)] = Field(10, description="Clusters to search (IVF)")
    use_gpu: Optional[bool] = Field(False, description="Enable GPU acceleration")


class Metric3(Enum):
    euclidean = "euclidean"
    cosine = "cosine"
    dotproduct = "dotproduct"


class Config53(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    api_key: str = Field(..., description="Pinecone API key")
    environment: Optional[str] = Field("us-east-1-aws", description="Pinecone environment")
    index_name: constr(pattern=r"^[a-z0-9-]+$") = Field(..., description="Index name")
    dimension: conint(ge=1, le=20000) = Field(..., description="Vector dimension")
    metric: Optional[Metric3] = Field("cosine", description="Distance metric")
    namespace: Optional[str] = Field("", description="Namespace for isolation")
    replicas: Optional[conint(ge=1, le=20)] = Field(1, description="Number of replicas")


class Config54(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    host: Optional[str] = Field("localhost", description="Server host")
    port: Optional[conint(ge=1, le=65535)] = Field(6333, description="Server port")
    grpc_port: Optional[conint(ge=1, le=65535)] = Field(6334, description="gRPC port")
    api_key: Optional[str] = Field(None, description="API key")
    collection_name: Optional[constr(pattern=r"^[a-zA-Z0-9_-]+$")] = Field(
        "documents", description="Collection name"
    )
    vector_size: conint(ge=1, le=65536) = Field(..., description="Vector dimension")
    distance: Optional[Distance] = Field("Cosine", description="Distance metric")
    on_disk: Optional[bool] = Field(False, description="Store vectors on disk")


class VectorStore1(BaseModel):
    type: Type8
    config: Union[Config51, Config52, Config53, Config54]


class Config55(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    top_k: Optional[conint(ge=1, le=1000)] = Field(10, description="Number of results")
    distance_metric: Optional[DistanceMetric] = Field("cosine", description="Distance metric")
    score_threshold: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None, description="Minimum similarity score"
    )


class RetrievalStrategy5(BaseModel):
    type: Literal["BasicSimilarityStrategy"] = Field(
        ..., description="Retrieval strategy type identifier"
    )
    config: Config55 = Field(..., title="Basic Similarity Configuration")


class Config56(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    top_k: Optional[conint(ge=1, le=1000)] = Field(10, description="Number of results")
    filters: Optional[dict[str, Union[str, float, bool, list[Union[str, float, bool]]]]] = Field(
        {}, description="Metadata filters"
    )
    filter_mode: Optional[FilterMode] = Field("pre", description="When to apply filters")
    fallback_multiplier: Optional[conint(ge=1, le=10)] = Field(
        3, description="Multiplier for post-filtering"
    )


class RetrievalStrategy6(BaseModel):
    type: Literal["MetadataFilteredStrategy"] = Field(
        ..., description="Retrieval strategy type identifier"
    )
    config: Config56 = Field(..., title="Metadata Filtered Configuration")


class Config57(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    num_queries: Optional[conint(ge=1, le=10)] = Field(3, description="Number of query variations")
    top_k: Optional[conint(ge=1, le=1000)] = Field(10, description="Results per query")
    aggregation_method: Optional[AggregationMethod] = Field(
        "weighted", description="Result aggregation method"
    )
    query_weights: Optional[list[confloat(ge=0.0, le=1.0)]] = Field(
        None, description="Weights for each query"
    )


class RetrievalStrategy7(BaseModel):
    type: Literal["MultiQueryStrategy"] = Field(
        ..., description="Retrieval strategy type identifier"
    )
    config: Config57 = Field(..., title="Multi Query Configuration")


class Config58(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    initial_k: Optional[conint(ge=10, le=1000)] = Field(30, description="Initial candidates")
    final_k: Optional[conint(ge=1, le=100)] = Field(10, description="Final results")
    rerank_factors: Optional[RerankFactors] = Field(None, description="Reranking factor weights")
    normalize_scores: Optional[bool] = Field(True, description="Normalize scores before combining")


class RetrievalStrategy8(BaseModel):
    type: Literal["RerankedStrategy"] = Field(..., description="Retrieval strategy type identifier")
    config: Config58 = Field(..., title="Reranked Configuration")


class Type9(Enum):
    BasicSimilarityStrategy = "BasicSimilarityStrategy"
    MetadataFilteredStrategy = "MetadataFilteredStrategy"
    MultiQueryStrategy = "MultiQueryStrategy"
    RerankedStrategy = "RerankedStrategy"


class Strategy2(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    type: Type9
    weight: Optional[confloat(ge=0.0, le=1.0)] = 1.0
    config: Optional[dict[str, Any]] = None


class Config59(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategies: Optional[list[Strategy2]] = Field(
        None, description="Sub-strategies to combine", max_length=5, min_length=2
    )
    combination_method: Optional[CombinationMethod] = Field(
        "weighted_average", description="Combination method"
    )
    final_k: Optional[conint(ge=1, le=1000)] = Field(10, description="Final number of results")


class RetrievalStrategy9(BaseModel):
    type: Literal["HybridUniversalStrategy"] = Field(
        ..., description="Retrieval strategy type identifier"
    )
    config: Config59 = Field(..., title="Hybrid Universal Configuration")


class Components1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    parser: Parser1 = Field(..., description="Parser configuration", title="Parser Configuration")
    extractors: Optional[list[Extractor1]] = Field(None, max_length=10)
    embedder: Embedder1 = Field(..., title="Embedder Configuration")
    vector_store: VectorStore1 = Field(..., title="Vector Store Configuration")
    retrieval_strategy: Union[
        RetrievalStrategy5,
        RetrievalStrategy6,
        RetrievalStrategy7,
        RetrievalStrategy8,
        RetrievalStrategy9,
    ] = Field(..., title="Retrieval Strategy Configuration")


class StrategyTemplates(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(pattern=r"^[a-z][a-z0-9_]*$", min_length=1, max_length=50) = Field(
        ...,
        description="Unique strategy identifier",
        examples=["simple", "customer_support", "legal_documents"],
    )
    description: constr(min_length=10, max_length=500) = Field(
        ..., description="Clear description of strategy purpose"
    )
    tags: Optional[list[Tag]] = Field(
        None,
        description="Tags for categorization",
        examples=[["production", "optimized"], ["development", "testing"]],
    )
    use_cases: Optional[list[UseCase]] = Field(None, description="Specific use cases", min_length=1)
    components: Components1 = Field(..., title="Strategy Components")


class Dependencies(BaseModel):
    required: Optional[list[str]] = None
    optional: Optional[list[str]] = None


class Parsers(BaseModel):
    description: Optional[str] = None
    class_name: Optional[str] = None
    module: Optional[str] = None
    use_cases: Optional[list[str]] = None
    dependencies: Optional[Dependencies] = None


class ComponentMetadata(BaseModel):
    parsers: Optional[dict[str, Parsers]] = None
    extractors: Optional[dict[str, dict[str, Any]]] = None
    embedders: Optional[dict[str, dict[str, Any]]] = None
    vector_stores: Optional[dict[str, dict[str, Any]]] = None
    retrieval_strategies: Optional[dict[str, dict[str, Any]]] = None


class CompatibilityRules(BaseModel):
    component_compatibility: Optional[dict[str, Any]] = None
    embedder_store_compatibility: Optional[dict[str, Any]] = None
    strategy_store_optimization: Optional[dict[str, Any]] = None


class ValidationRules(BaseModel):
    required_fields: Optional[dict[str, Any]] = None
    field_constraints: Optional[dict[str, Any]] = None
    performance_warnings: Optional[list[dict[str, Any]]] = None


class Rag(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    strategies: list[Strategy] = Field(
        ...,
        description="Array of strategy configurations",
        min_length=1,
        title="Strategy Definitions",
    )
    strategy_templates: Optional[dict[str, StrategyTemplates]] = Field(
        {},
        description="Ready-to-use strategy configurations",
        title="Predefined Strategy Templates",
    )
    component_metadata: Optional[ComponentMetadata] = Field(
        None, description="Metadata about available components", title="Component Metadata"
    )
    compatibility_rules: Optional[CompatibilityRules] = Field(
        None, description="Rules for component compatibility", title="Component Compatibility Rules"
    )
    validation_rules: Optional[ValidationRules] = Field(
        None, description="System-wide validation rules", title="Validation Rules"
    )
    best_practices: Optional[dict[str, list[str]]] = Field(
        None, description="Recommended configuration patterns", title="Best Practices"
    )


class Dataset(BaseModel):
    name: str = Field(..., description="Dataset name")
    rag_strategy: Optional[str] = Field("auto", description="RAG strategy to use for the dataset")
    files: list[str] = Field(..., description="List of file hashes")


class Provider(Enum):
    openai = "openai"
    ollama = "ollama"


class Runtime(BaseModel):
    provider: Provider
    model: str = Field(..., description="Model name or ID")
    base_url: Optional[str] = Field(None, description="Base URL for the provider")
    api_key: Optional[str] = Field(None, description="API key for the provider")
    instructor_mode: Optional[str] = Field(
        None, description="Instructor mode to use for the provider"
    )
    model_api_parameters: Optional[Any] = Field(
        None, description="Additional parameters passed to the API provider"
    )


class LlamaFarmConfig(BaseModel):
    version: Version = Field(..., description='Config version, must be "v1"')
    name: str = Field(..., description="Project name", examples=["my-project"])
    namespace: str = Field(..., description="Project namespace", examples=["my-namespace"])
    prompts: list[Prompt]
    rag: Rag = Field(
        ...,
        description="Schema for RAG system strategy configurations",
        title="RAG Strategy Configuration Schema",
    )
    datasets: list[Dataset] = Field(..., description="List of dataset configurations")
    runtime: Runtime
